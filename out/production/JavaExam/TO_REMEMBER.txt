============

Following the Order of Initialization:
- Fields and instance initializer blocks are run in the order in which they appear in the file
- The constructor runs after all fields and instance initializer blocks have run

============

The primitive types:
byte -> short -> int -> long -> float -> double -> char

============

Signed and Unsigned: short and char
You should be aware that short and char are closely related, as both are stored as integral types with the same 16-bit length.
The primary difference is that short is signed, which means it splits its range across the positive and negative integers.
Alternatively, char is unsigned, which means its range is strictly positive, including 0.

============

Literals and the Underscore Character
int million = 1_000_000;
You can add underscores anywhere
- except at the beginning of a literal,
- except at the end of a literal,
- except at right before a decimal point, or right after a decimal point.
You can even place multiple underscore characters next to each other, although we don’t recommend it

double notAtStart = _1000.00; // DOES NOT COMPILE
double notAtEnd = 1000.00_; // DOES NOT COMPILE
double notByDecimal = 1000_.00; // DOES NOT COMPILE
double annoyingButLegal = 1_00_0.0_0; // Ugly, but compiles
double reallyUgly = 1__________2; // Also compiles

============

There are only four rules to remember for legal identifiers:
■ Identifiers must begin with a letter, a currency symbol, or a _ symbol.
  Currency symbols include dollar ($), yuan (¥), euro (€), and so on.
■ Identifiers can include numbers but not start with them.
■ A single underscore _ is not allowed as an identifier.
■ You cannot use the same name as a Java reserved word.
  A reserved word is a special word that Java has held aside so that you are not allowed to use it.
  Java is case sensitive, so you can use versions of the keywords that only differ in case.

The exam will only ask you about ones that are commonly used, such as class and for.

============

Local variables do not have a default value and must be initialized before use.
On the exam, be wary of any local variable that is declared but not initialized in a single line.
This is a common place on the exam that could result in a “Does not compile” answer.
Be sure to check to make sure it’s initialized before it’s used on the exam.

============

Variables that are not local variables are defined either as instance variables or as class variables.
Instance and class variables do not require you to initialize them.
As soon as you declare these variables, they are given a default value.

An instance variable - often called a field, is a value defined within a specific instance of an object.
A class variable (aka static) - is one that is defined on the class level and shared among all instances of the class.

============

VAR
- you can only use this feature for local variables.
- local variable type inference (var) works with local variables and not instance variables.
- local variable type inference (var), the compiler looks only at the line with the declaration.
- While a var cannot be initialized with a null value without a type,
  it can be reassigned a null value after it is declared, provided that the underlying data type is a reference type.
- var is not a reserved word and allowed to be used as an identifier.

============

IMPORTANT --> Order of operator precedence --> Table on 134,135 (68, 69) Page

============

Primitive numeric promotion when applying:
- If two values have different data types,
  Java will automatically promote one of the values to the larger of the two data types.
- If one of the values is integral and the other is floating-point,
  Java will automatically promote the integral value to the floating-point value’s data type
- Smaller data types (byte, short, and char) are first promoted to int any time they’re used with
  a Java binary arithmetic operator with a variable (as opposed to a value), even if neither of the operands is int.
- After all promotion has occurred and the operands have the same data type,
  the resulting value will have the same data type as its promoted operands.

Casting is optional and unnecessary when converting to a larger or widening data type,
but it is required when converting to a smaller or narrowing data type.

Casting primitives is required any time when:
- you are going from a larger numerical data type to a smaller numerical data type,
- you are converting from a floating-point number to an integral value.

============

Pattern Variables

void compareIntegers(Number number) {
  if (number instanceof Integer data) {
    System.out.print(data.compareTo(5));
  }
}

The type of the pattern variable must be a subtype of the variable on the left side of the
expression. It also cannot be the same type. This rule does not exist for traditional instanceof
operator expressions, though.

Integer value = 123;
if(value instanceof Integer) {}
if(value instanceof Integer data) {} // DOES NOT COMPILE

============

SWITCH STATEMENT

switch(month) {
 case 1, 2: System.out.print("January");
}

switch statement is not required to contain any case statements: switch(month) {}

the values in each case statement must be compile-time constant values of the same data type as the switch value.
This means you can use only literals, enum constants, or final constant variables of the same data type.

final int getCookies() { return 4; }
void feedAnimals() {
  final int bananas = 1;
  int apples = 2;
  int numberOfAnimals = 3;
  final int cookies = getCookies();
  switch(numberOfAnimals) {
    case bananas:
    case apples: // DOES NOT COMPILE
    case getCookies(): // DOES NOT COMPILE
    case cookies : // DOES NOT COMPILE
    case 3 * 5 :
  }
}

The following is a list of all data types supported by switch statements:
■ int and Integer
■ byte and Byte
■ short and Short
■ char and Character
■ String
■ enum values
■ var (if the type resolves to one of the preceding types)

============

SWITCH EXPRESSION
- we can now assign the result of a switch expression to a variable result
- all case and default branches must return a data type that is compatible with the assignment
- semicolon is required after each switch expression
- case statements can take multiple values, separated by commas
- all of the branches of a switch expression that do not throw an exception must return a consistent data type
  (if the switch expression returns a value).
- if the switch expression returns a value, then every branch that isn’t an expression must yield a value.
- default branch is required unless all cases are covered or no value is returned.

int measurement = 10;
int size = switch(measurement) {
  case 5 -> 1;
  case 10 -> (short)2;
  default -> 5;
  case 20 -> "3"; // DOES NOT COMPILE
  case 40 -> 4L; // DOES NOT COMPILE
  case 50 -> null; // DOES NOT COMPILE
};

var name = switch(fish) {
  case 1 -> "Goldfish" // DOES NOT COMPILE (missing semicolon)
  case 2 -> {yield "Trout";}; // DOES NOT COMPILE (extra semicolon)
  ...
 } // DOES NOT COMPILE (missing semicolon)

============

LOOPS

- Curly braces required for block of multiple statements and optional for single statement
- break statement transfers the flow of control out to the enclosing statement.
- without a label parameter, the break statement will terminate the nearest inner loop it is currently in the process
- the optional label parameter allows us to break out of a higher-level outer loop
- continue statement causes flow to finish the execution of the current loop iteration (ends the current iteration of the loop)
- code placed after 'break', 'continue' and 'return' in the same block is considered unreachable and will not compile.

For loop:
- for( ; ; ) --> it will be infinite loop that will execute the same statement repeatedly
- the semicolons separating the three sections are required, as for( ) without any semicolons will not compile.
- You can declare multiple elements in a for loop, but the data type must be listed only once
  for(int i=0, j=3; ...)
- The variables in the initialization block must all be of the same type:
  for(long y = 0, int z = 4; x < 5; x++) // DOES NOT COMPILE

For-each loop:
- right side must be an array or collection of items, such as a List or a Set (include only Collection interface)

Decision --- labels --- break --- continue --- yield
while    --- Yes        Yes       Yes          No
do/while --- Yes        Yes       Yes          No
for      --- Yes        Yes       Yes          No
switch   --- Yes        Yes       No           Yes

============

STRING
- is a sequence of characters
- counts from 0 when indexed
- is immutable, or unchangeable

String name = "Fluffy";
String name = new String("Fluffy");
String name = """
                Fluffy""";

System.out.println(1 + 2);          // 3
System.out.println("a" + "b");      // ab
System.out.println("a" + "b" + 3);  // ab3
System.out.println(1 + 2 + "c");    // 3c
System.out.println("c" + 1 + 2);    // c12
System.out.println("c" + null);     // cnull

Substring:
- first parameter is the index to start with for the returned string (zero-based index)
- optional second parameter is the end index you want to stop at (we said “stop at” rather than “include”)

System.out.println(name.substring(3, 3)); // empty string
System.out.println(name.substring(3, 2)); // exception
System.out.println(name.substring(3, 8)); // exception, cuz string in name variable has 7 characters

Removing Whitespace:
String strip() and String trim() - methods remove blank space from the beginning and/or end of a String
String stripLeading() - method removes whitespace from the beginning of the String and leaves it at the end.
String stripTrailing() - method removes whitespace from the end of the String and leaves it at the beginnning.

The strip() method does everything that trim() does, but it supports Unicode
In terms of the exam, whitespace consists of spaces along with the \t (tab) and \n (newline) characters.

============

String indent(int numberSpaces)
- adds the same number of blank spaces to the beginning of each line if you pass a positive number.
- If you pass a negative number, it tries to remove that number of whitespace characters from the beginning of the line.
- If you pass zero, the indentation will not change.
- it also normalizes whitespace characters:
  --> line break is added to the end of the string if not already there
  --> any line breaks are converted to the \n format.
  --> Regardless of whether your operating system uses \r\n (Windows) or\n (Mac/Unix), Java will standardize on \n for you.

String stripIndent()
- It gets rid of all incidental whitespace
- all non-blank lines are shifted left so the same number of whitespace characters are removed from each line
and the first character that remains is not blank
- \r\n is turned into \n
- method does not add a trailing line break if it is missing

public boolean isEmpty() - check if String has length of zero
public boolean isBlank() - check if String contains only whitespace or has length of zero

============

Formatting String
%s --> Applies to any type, commonly String values
%d --> Applies to integer values like int and long
%f --> Applies to floating-point values like float and double
%n --> Inserts a line break using the system-dependent line separator

Mixing data types may cause exceptions at runtime - IllegalFormatConversionException

By default, %f displays exactly six digits past the decimal.
If you want to display only one digit after the decimal, you can use %.1f instead of %f
The format() method relies on rounding rather than truncating when shortening numbers
90.250000 will be displayed as 90.3 (not 90.2) when passed to format() with %.1f

============

STRING BUILDER
- it changes its own state and returns a reference to itself.
- these four methods work exactly the same as in the String class: charAt, substring, indexOf, substring

StringBuilder sb3 = new StringBuilder(10) - tells Java that we have some idea of how big the
eventual value will be and would like the StringBuilder to reserve a certain capacity or number of slots

StringBuilder append(String str)
  -> adds the parameter to the StringBuilder and returns a reference to the current StringBuilder
StringBuilder insert(int offset, String str)
  -> adds characters to the StringBuilder at the requested index and returns a reference to the current StringBuilder.
StringBuilder delete(int startIndex, int endIndex)
  -> removes characters from the sequence and returns a reference to the current StringBuilder
StringBuilder deleteCharAt(int index)
  -> method is convenient when you want to delete only one character.
StringBuilder replace(int startIndex, int endIndex, String newString)
  -> deletes the characters starting with 'startIndex' and ending right before 'endIndex'
     Then inserts the value 'newString' in that position

var name = "a";
var builder = new StringBuilder("a");
System.out.println(name == builder); // DOES NOT COMPILE
Remember that == is checking for object reference equality. The compiler is smart enough
to know that two references can’t possibly point to the same object when they are completely different types.

var x = "Hello World";
var y = "Hello World";
System.out.println(x == y); // true
Remember that a String is immutable and literals are pooled. The JVM created only one literal in memory.

var name = "Hello World";
var name2 = new String("Hello World").intern();
System.out.println(name == name2); // true
The intern() method will use an object in the string pool if one is present.

============

ARRAYS

Arrays declaration:
int[] numAnimals;
int [] numAnimals;
int []numAnimals;
int numAnimals[];
int numAnimals [];

int[][] vars1; // 2D array
int vars2 [][]; // 2D array
int[] vars3[]; // 2D array
int[] vars4 [], space [][]; // a 2D AND a 3D array

Remember -> The type 'int' is a primitive; 'int[]' is an object.

The array does not allocate space for the String objects.
Instead, it allocates space for a reference to where the objects are really stored.

String[] mammals = {"monkey", "chimp", "donkey"};
int counter = mammals.length;
Note that there are no parentheses after length since it is not a method.
The length attribute does not consider what is in the array; it only considers how many slots have been allocated.

Arrays.toString(tempArray) --> Method for printing values from array
Arrays.sort(tempArray) --> Method for sorting values which are in array
Arrays.binarySearch(tempArray, value) --> Method for searching specific value in array

Arrays comparing - compare()
- If both arrays are the same length and have the same values in each spot in the same order, return zero,
- If all the elements are the same but the second array has extra elements at the end, return a negative number,
- If all the elements are the same, but the first array has extra elements at the end, return a positive number,
- If the first element that differs is smaller in the first array, return a negative number,
- If the first element that differs is larger in the first array, return a positive number,

============

DATES and TIMES

var d = new LocalDate(); // DOES NOT COMPILE
You are not allowed to construct a date or time object directly

var d = LocalDate.of(2022, Month.JANUARY, 32) // DateTimeException
trick is what happens when you pass invalid numbers to of()

var date = LocalDate.of(2024, Month.JANUARY, 20);
date.plusDays(10);
System.out.println(date); // It prints January 20, 2024
Whenever you see immutable types, pay attention to make sure that the return value of a method call isn’t ignored

var date = LocalDate.of(2024, Month.JANUARY, 20);
date = date.plusMinutes(1); // DOES NOT COMPILE
LocalDate does not contain time. This means that you cannot add minutes to it

Period is a day or more of time.
var annually = Period.ofYears(1); // every 1 year P1Y
var quarterly = Period.ofMonths(3); // every 3 months P3M
var everyThreeWeeks = Period.ofWeeks(3); // every 3 weeks P21D
var everyOtherDay = Period.ofDays(2); // every 2 days P2D
var everyYearAndAWeek = Period.of(1, 0, 7); // every year and 7 days P1Y7D
var wrong = Period.ofYears(1).ofWeeks(1); // every week P1Y7D

Duration, which is intended for smaller units of time.
var daily = Duration.ofDays(1); // PT24H
var hourly = Duration.ofHours(1); // PT1H
var everyMinute = Duration.ofMinutes(1); // PT1M
var everyTenSeconds = Duration.ofSeconds(10); // PT10S
var everyMilli = Duration.ofMillis(1); // PT0.001S
var everyNano = Duration.ofNanos(1); // PT0.000000001S

var daily = Duration.of(1, ChronoUnit.DAYS);
var hourly = Duration.of(1, ChronoUnit.HOURS);
var everyMinute = Duration.of(1, ChronoUnit.MINUTES);
var everyTenSeconds = Duration.of(10, ChronoUnit.SECONDS);
var everyMilli = Duration.of(1, ChronoUnit.MILLIS);
var everyNano = Duration.of(1, ChronoUnit.NANOS);

var one = LocalTime.of(5, 15);
var two = LocalTime.of(6, 30);
var date = LocalDate.of(2016, 1, 20);
System.out.println(ChronoUnit.HOURS.between(one, two)); // 1
System.out.println(ChronoUnit.MINUTES.between(one, two)); // 75
System.out.println(ChronoUnit.MINUTES.between(one, date)); // DateTimeException

var date = LocalDate.of(2022, 5, 25);
var period = Period.ofDays(1);
var days = Duration.ofDays(1);
System.out.println(date.plus(period)); // 2022–05–26
System.out.println(date.plus(days)); // Unsupported unit: Seconds

Since we are working with a LocalDate, we are required to use Period
Period   --> LocalDate, LocalDateTime, ZonedDateTime
Duration --> LocalDateTime, LocalTime, ZonedDateTime

var now = Instant.now();
The Instant class represents a specific moment in time in the GMT time zone.

============

Access modifiers:
private - method can be called only from within the same class,
no keyword (package access) - method can be called only from a class in the same package,
protected - method can be called only from a class in the same package or a subclass,
public - method can be called from anywhere

Optional specifiers:
- while access modifiers and optional specifiers can appear in any order, they must all appear before the return type.
- you can’t declare a method (or class) both final and abstract
- method must have a return type (if no value is returned the void keyword must be used)

Method name:
- an identifier may only contain letters, numbers, currency symbols, or _.
- first character is not allowed to be a number
- reserved words are not allowed
- the single underscore character is not allowed

public void 2jog() {} // DOES NOT COMPILE
public _() {} // DOES NOT COMPILE

============

Varargs
- a method can have at most one varargs parameter
- if a method contains a varargs parameter, it must be the last parameter in the list
- you can pass in an array, or you can list the elements of the array

===========

static
- you can think of a static variable as being a member of the single class object
- exists independently of any instances of that class
- all instances of class must share the same state

Snake s = new Snake();
System.out.println(s.hiss); // s is a Snake
s = null;
System.out.println(s.hiss); // s is still a Snake

============

Passing Data
- Java is "pass-by-value" language
- copy of the variable is made and the method receives that copy
- assignments made in the method do not affect the caller

============

Autoboxing and Unboxing Variables
- Autoboxing is the process of converting a primitive into its equivalent wrapper class,
- unboxing is the process of converting a wrapper class into its equivalent primitive

While Java will implicitly cast a smaller primitive to a larger type, as well as autobox, it will not do both at the same time.
--> Long badGorilla = 8; // DOES NOT COMPILE
--> long goodGorilla = Integer.valueOf(8);

Java will cast or autobox the value automatically, but not both at the same time.

============

INHERITANCE
- superclass cannot be marked as a final
- Java supports single inheritance, by which a class may inherit from only one direct parent class,
- Java supports multiple levels of inheritance, by which one class may extend another class, which in turn extends another class.
- all classes inherit from a single class: java.lang.Object
- Object is the only class that doesn’t have a parent class.

Class modifiers:
final - The class may not be extended
abstract - The class is abstract, may contain abstract methods, and requires a concrete subclass to instantiate
sealed - The class may only be extended by a specific list of classes,
non-sealed - A subclass of a sealed class permits potentially unnamed subclasses
static - Used for static nested classes defined within a class

============

this
- refers to the current instance of the class
- can be used to access any member of the class, including inherited members.
- can be used in any instance method, constructor, or instance initializer block.
- cannot be used when there is no implicit instance of the class, such as in a static method or static initializer block.
- Accessing this.variableName can be performed from any instance method, constructor, or instance initializer,
  (but not from a static method or static initializer)

super
- allows do the reference the version in the parent class instead of the current class
- excludes any members found in the current class

Remember, while 'this' includes current and inherited members, 'super' only includes inherited members.

============

CONSTRUCTORS
- the name of the constructor matches the name of the class
- there is no return type (not even void)
- constructor parameters can be any valid class, array, or primitive type, including generics, but may not include var
- class can have multiple constructors, as long as each constructor has a unique constructor signature
- compiler only inserts the default constructor when no constructors are defined !!!
- constructors can be called only by writing new before the name of the constructor
- Calling an overloaded constructor with this() may be used only as the first line of a constructor

The first statement of every constructor is a call to a parent constructor using super() or
another constructor in the class using this().

When Java sees the new keyword, it allocates memory for the new object.
It then looks for a constructor with a matching signature and calls it.

Java compiler automatically inserts a call to the no-argument constructor super()
if you do not explicitly call this() or super() as the first line of a constructor

Private constructor:
Having only private constructors in a class tells the compiler not to provide a default no-argument constructor.
It also prevents other classes from instantiating the class. This is useful when a class has only static methods
or the developer wants to have full control of all calls to create new instances of the class

this()
- when this() is used with parentheses, Java calls another constructor on the same instance of the class
- 'this' refers to an instance of the class, while 'this()' refers to a constructor call within the class
- this() call must be the first statement in the constructor
- Java does not allow cyclic constructor calls
- this() can only be called from a constructor in the same class

super()
- 'super', is used to reference members of the parent class, while the second, 'super()', calls a parent constructor.
- calling super() can only be used as the first statement of the constructor
- compiler automatically inserts a call to the no-argument constructor super()
  if you do not explicitly call this() or super() as the first line of a constructor
- super() always refers to the most direct parent

============

Initializing Objects

Initializing Classes (Order of initialization)
1. If there is a superclass Y of X, then initialize class Y first.
2. Process all static variable declarations in the order in which they appear in the class. (from parent first)
3. Process all static initializers in the order in which they appear in the class. (from parent first)

Initializing final Fields
- final instance variables must be assigned a value
- default value is only applied to a non-final
- 'final' variables can be assigned values in the line in which they are declared or in an instance initializer
- final instance fields can also be set in a constructor
- by the time the constructor completes, all final instance variables must be assigned a value exactly once
- can assign a null value to final instance variables as long as they are explicitly set.

Initializing Instances
1. Initialize class X if it has not been previously initialized.
2. If there is a superclass Y of X, then initialize the instance of Y first.
3. Process all instance variable declarations in the order in which they appear in the class.
4. Process all instance initializers in the order in which they appear in the class.
5. Initialize the constructor, including any overloaded constructors referenced with this().

■ A class is initialized at most once by the JVM before it is referenced or used.
■ All static final variables must be assigned a value exactly once, either when they are declared or in a static initializer.
■ All final fields must be assigned a value exactly once, either when they are declared, in an instance initializer, or in a constructor.
■ Non-final static and instance variables defined without a value are assigned a default value based on their type.
■ Order of initialization is as follows: variable declarations, then initializers, and finally constructors.

============

Overloading
- Overloaded methods have the same method name but a different signature (the method parameters differ)
- Overloaded methods can have different return types

Overriding
- method signature is composed of the name of the method and method parameters.
- The method in the child class must have the same signature as the method in the parent class.
- The method in the child class must be at least as accessible as the method in the parent class
  (the subclass cannot reduce the visibility of the parent method)
- The method in the child class may not declare a checked exception
  that is new or broader than the class of any exception declared in the parent class method.
- If the method returns a value, it must be the same or a subtype of the method in the parent class,
  known as covariant return types.
- you can’t override private methods since they are not inherited,
  but you can redeclare a new method in the child class with the same or modified signature as the method in the parent class.
- the method defined in the child class must be marked as static if it is marked as static in a parent class.
- Java doesn’t allow variables to be overridden (Variables can be hidden)
- final methods cannot be overridden
- you cannot hide a static method in a child class if it is marked final
- Overridden instance methods and hidden static methods must have the same signature (the name and method parameters must match),
- overridden and hidden methods can have covariant return types

Covariant Return Types
A simple test for covariance is the following: given an inherited return type A and an overriding return type B,
can you assign an instance of B to a reference variable for A without a cast? If so, then they are covariant.
This rule applies to primitive types and object types alike.
If one of thereturn types is void, then they both must be void, as nothing is covariant with void except itself.

============

Abstract class
- it is a class declared with the abstract modifier that cannot be instantiated directly and may contain abstract methods.
- abstract method is a method declared with the abstract modifier that does not define a body
- only instance methods can be marked abstract within a class, not variables, constructors, or static methods
- An abstract method can only be declared in an abstract class.
- A non-abstract class that extends an abstract class must implement all inherited abstract methods
- abstract method is always declared without a body
- abstract class can extend a non-abstract class and another abstract class
- abstract classes are initialized with constructors in the same way as non-abstract classes
- Java does not permit a class or method to be marked both abstract and final
- abstract method cannot be marked as both abstract and private
- abstract method cannot be marked as both abstract and static

The abstract modifier cannot be placed after the class keyword in a class declaration or after the return type in a method declaration.
public class abstract Bear { // DOES NOT COMPILE
 public int abstract howl(); // DOES NOT COMPILE
}

============

Immutable Objects
- an immutable object is one that cannot change state after it is created.

Common strategy for making a class immutable:
1. Mark the class as final or make all of the constructors private.
2. Mark all the instance variables private and final.
3. Don’t define any setter methods.
4. Don’t allow referenced mutable objects to be modified.
5. Use a constructor to set all properties of the object, making a copy if needed.

============

Interface
- An interface is an abstract data type that declares a list of abstract methods
  that any class implementing the interface must provide.
- interfaces cannot be marked as final
- interface methods could be private and public only
- interface can extend multiple interfaces
- Java supports inheriting two abstract methods that have compatible method declarations
  By compatible, we mean a method can be written that properly overrides both inherited methods

Inserting Implicit Modifiers
- Interfaces are implicitly abstract
- Interface variables are implicitly public, static, and final.
- Interface methods without a body are implicitly abstract.
- Interface methods without the private modifier are implicitly public.
  (The last rule applies to abstract, default, and static interface methods)

Default Interface Method Definition Rules
1. A default method may be declared only within an interface.
2. A default method must be marked with the default keyword and include a method body.
3. A default method is implicitly public.
4. A default method cannot be marked abstract, final, or static.
5. A default method may be overridden by a class that implements the interface.
6. If a class inherits two or more default methods with the same method signature, then the class must override the method.

Static Interface Method Definition Rules
1. A static method must be marked with the static keyword and include a method body
2. A static method without an access modifier is implicitly public.
3. A static method cannot be marked abstract or final.
4. A static method is not inherited and cannot be accessed in a class implementing the interface without a reference to the interface name

Private Interface Method Definition Rules
1. A private interface method must be marked with the private modifier and include a method body.
2. A private static interface method may be called by any method within the interface definition.
3. A private interface method may only be called by default and other private nonstatic methods within the interface definition.

Tips on exam:
■ Treat abstract, default, and non-static private methods as belonging to an instance of the interface.
■ Treat static methods and variables as belonging to the interface class object.
■ All private interface method types are only accessible within the interface declaration.

============

ENUMS
- each enum value is initialized only once in the Java Virtual Machine (JVM).
- all enum constructors are implicitly private, with the modifier being optional
- enum constructor will not compile if it contains a public or protected modifier
- The first time we ask for any of the enum values, Java constructs all of the enum values
- enum can even implement an interface
- whether the enum is simple or complex, the list of values always comes first.

============

SEALING CLASS

public sealed class Bear permits Kodiak, Panda {}
public final class Kodiak extends Bear {}
public non-sealed class Panda extends Bear {}

■ final: jeżeli chcemy zamknąć hierarchię dziedziczenia,
■ sealed: Indicates that a class or interface may only be extended/implemented by named classes or interfaces
■ permits: Used with the sealed keyword to list the classes and interfaces allowed
■ non-sealed: Applied to a class or interface that extends a sealed class, indicating that it can be extended by unspecified classes

- Sealed classes are commonly declared with the abstract modifier, although this is certainly not required.
- Sealed class needs to be declared (and compiled) in the same package or named module as its direct subclasses
- Every class that directly extends a sealed class must specify exactly one of the following three modifiers:
  final, sealed, or non-sealed !!!
- The permits clause is optional if the sealed class and its direct subclasses are declared
  within the same file or the subclasses are nested within the sealed class.
- While it makes the code easier to read if you omit the permits clause for nested subclasses, you are welcome to name them:
  public sealed class Snake permits Snake.Cobra {
    final class Cobra extends Snake {}
  }

Sealing Interfaces
- the sealed interface must appear in the same package or named module as the classes or interfaces that directly extend or implement it
- the permits list can apply to a class that implements the interface or an interface that extends the interface
- remember that interfaces are implicitly abstract and cannot be marked final
- interfaces that extend a sealed interface can only be marked sealed or non-sealed (they cannot be marked final)

============

Records

Members Automatically Added to Records:
■ Constructor: A constructor with the parameters in the same order as the record declaration
■ Accessor method: One accessor for each field
■ equals(): A method to compare two elements that returns true if each field is equal in terms of equals()
■ hashCode(): A consistent hashCode() method using all of the fields
■ toString(): A toString() implementation that prints each field of the record in a convenient, easy-to-read format

- it is legal to have a record without any fields
- records don’t have setters
- every field is inherently final and cannot be modified after it has been written in the constructor
- in order to “modify” a record, you have to make a new object and copy all of the data you want to preserve.
- just as interfaces are implicitly abstract, records are also implicitly final
- you can’t extend or inherit a record
- also like enums, a record can implement a regular or sealed interface, provided it implements all of the abstract methods

While you can add methods, static fields, and other data types,
you cannot add instance fields outside the record declaration, even if they are private:
public record Crane(int numberEggs, String name) {
  private static int type = 10;
  public int size; // DOES NOT COMPILE
  private boolean friendly; // DOES NOT COMPILE
}

Long constructor:
- it must have all parameters from record declared inside body
- Since each field is final, the constructor must set every field.

Compact constructor:
- special type of constructor used for records to process validation and transformations succinctly.
- It takes no parameters and implicitly sets all fields
- Long constructor is implicitly called at end of compact constructor
- You should also remember that a compact constructor is declared without parentheses
- While compact constructors can modify the constructor parameters, they cannot modify the fields of the record. !!!

Overloaded Constructors
- You can also create overloaded constructors that take a completely different list of parameters.
- The first line of an overloaded constructor must be an explicit call to another constructor via this()
- If there are no other constructors, the long constructor must be called
- you can only transform the data on the first line
  (After the first line, all of the fields will already be assigned and the object is immutable.)

============

NESTED CLASS

- All four types of nested classes can now define static variables and methods!

Nested class can come in one of four flavors:
■ Inner class:
- A non-static type defined at the member level of a class (the same level as the methods, instance variables, and constructors)
- Can be declared public, protected, package, or private
- Can extend a class and implement interfaces
- Can be marked abstract or final
- Can access members of the outer class, including private members
- Instantiating an Instance of an Inner Class:
  var home = new Home();
  Room room = home.new Room(); // Create the inner class instance
- Inner classes can have the same variable names as outer classes

■ Static nested class:
- A static type defined at the member level of a class
- it can’t access instance variables or methods declared in the outer class
- static nested class can be instantiated without an instance of the enclosing class
- The enclosing class can refer to the fields and methods of the static nested class.

■ Local class:
- A class defined within a method body
- local class declaration does not exist until the method is invoked (you can create instances only from within the method)
- it does not have an access modifier
- it can be declared final or abstract
- it has access to all fields and methods of the enclosing class
- it can access final and effectively final local variables

■ Anonymous class:
- A special case of a local class that does not have a name
- it must extend an existing class or implement an existing interface
- it is useful when you have a short implementation that will not be used anywhere else
- you can't both implement an interface and extend a class with a anonymous class

============

Polymorphism

- Polymorphism’s ability to replace methods at runtime via overriding is one of the most important properties of Java
- you can choose to limit polymorphic behavior by marking methods final, which prevents them from being overridden by a subclass.

Java object may be accessed using:
■ A reference with the same type as the object
■ A reference that is a superclass of the object
■ A reference that defines an interface the object implements or inherits

- In Java, all objects are accessed by reference!
- The type of the object determines which properties exist within the object in memory.
- The type of the reference to the object determines which methods and variables are accessible to the Java program.
- Depending on the type of the reference, we may only have access to certain methods

Casting Objects:
0. Casting objects is similar to casting primitives
1. Casting a reference from a subtype to a supertype doesn’t require an explicit cast.
2. Casting a reference from a supertype to a subtype requires an explicit cast.
3. At runtime, an invalid cast of a reference to an incompatible type results in a ClassCastException being thrown.
4. The compiler disallows casts to unrelated types.

The 'instanceof' Operator
- The instanceof operator can be used to check whether an object belongs to a particular class or interface
  and to prevent a ClassCastException at runtime.
- compiler does not allow instanceof to be used with unrelated types

============

LAMBDA EXPRESSION

Lambda syntax omitting optional parts: a -> a.canHop()
- A single parameter specified with the name 'a'
- The arrow operator (->) to separate the parameter and body
- A body that calls a single method and returns the result of that method
- the parentheses are optional only when there is one parameter and it doesn’t have a type declared
- The parentheses around the lambda parameters can be omitted only if there is a single parameter and its type is not explicitly stated

Lambda syntax including optional parts: (Animal a) -> { return a.canHop(); }
- A single parameter specified with the name a and stating that the type is Animal
- The arrow operator (->) to separate the parameter and body
- A body that has one or more lines of code, including a semicolon and a return statement

Valid lambdas that return a boolean:
() -> true
x -> x.startsWith("test")
(String x) -> x.startsWith("test")
(x, y) -> { return x.startsWith("test"); }
(String x, String y) -> x.startsWith("test")

Invalid lambdas that should return a boolean:
x, y -> x.startsWith("fish") Missing parentheses on left
x -> { x.startsWith("camel"); } Missing return on right
x -> { return x.startsWith("giraffe") } Missing semicolon inside braces
String x -> x.endsWith("eagle") Missing parentheses on left

5: (var x, y) -> "Hello" // DOES NOT COMPILE
6: (var x, Integer y) -> true // DOES NOT COMPILE
7: (String x, var y, Integer z) -> true // DOES NOT COMPILE
8: (Integer x, y) -> "goodbye" // DOES NOT COMPILE
Lines 5 needs to remove var from x or add it to y. Next, lines 6 and 7 need to use the type
or var consistently. Finally, line 8 needs to remove Integer from x or add a type to y.

- Lambdas work with functional interfaces that have exactly one abstract method
  Your friend Sam can help you remember this because it is officially known as a single abstract method (SAM) rule.
- The @FunctionalInterface annotation tells the compiler that you intend for the code to be a functional interface.
  If the interface does not follow the rules for a functional interface, the compiler will give you an error.
  Remember that having exactly one abstract method is what makes it a functional interface, not the annotation.
- If a functional interface includes an abstract method with the same signature as a public method found in Object,
  those methods do not count toward the single abstract method test (toString(), equals(Object), hashCode()).
- Even though default methods function like abstract methods, in that they can be overridden in a class implementing the interface,
  they are insufficient for satisfying the single abstract method requirement.
- Lambda can access an instance variable, method parameter, or local variable under certain conditions
  Instance variables (and class variables) are always allowed.
- The only thing lambdas cannot access are variables that are not final or effectively final.
  It means, variable cannot be change after lambda execution

============

METHOD REFERENCE

Method reference: LearnToSpeak learner = System.out::println;
- The :: operator tells Java to call the println() method later
- Remember that :: is like a lambda, and it is used for deferred execution with a functional interface.

There are four formats for method references:
1) Calling static Methods
  Before colon: class name, After colon: method name
  Converter methodRef = Math::round;
  Converter lambda = x -> Math.round(x);

2) Calling Instance Methods on a Particular Object
  Before colon: instance variable name, After colon: method name
  var str = "Zoo";
  StringStart methodRef = str::startsWith;
  StringStart lambda = s -> str.startsWith(s);

3) Calling Instance Methods on a Parameter
  Before colon: class name, After colon: method name
  StringParameterChecker methodRef = String::isEmpty;
  StringParameterChecker lambda = s -> s.isEmpty();

  Since the functional interface takes two parameters, Java has to figure out what they represent.
  The first one will always be the instance of the object for instance methods. Any others are to be method parameters
  StringTwoParameterChecker methodRef = String::startsWith;
  StringTwoParameterChecker lambda = (s, p) -> s.startsWith(p);

4) Calling Constructors
  Before colon: class name, After colon: "new"
  A constructor reference is a special type of method reference that uses new instead of a method and instantiates an object.
  EmptyStringCreator methodRef = String::new;
  EmptyStringCreator lambda = () -> new String();

============

FUNCTIONAL INTERFACE

For the exam you need to memorize this table: TABLE 8.4
You need to know the table really well.
It’s really important to know the number of parameters, types, return value,
and method name for each of the functional interfaces.
Table 8.5 shows the convenience methods on the built-in functional interfaces that you need to know for the exam
Table 8.6 contains all Functional Interfaces for primitives

- By definition, all functional interfaces have a single abstract method
- Several of the common functional interfaces provide a number of helpful default interface methods
- Other interface method types (default, private, static, and private static) do not count toward
  the single abstract method count, nor do any public methods with signatures found in Object.

Supplier
- is used when you want to generate or supply values without taking any input
Consumer
- when you want to do something with a parameter but not return anything
BiConsumer
- when you want to do something with two parameters but not return anything
Predicate
- is often used when filtering or matching
- returns a boolean primitive and not a Boolean object
BiPredicate
- is often used when filtering or matching, but takes two parameters
- returns a boolean primitive and not a Boolean object
Function
- is responsible for turning one parameter into a value of a potentially different type and returning it
BiFunction
- is responsible for turning two parameters into a value and returning it.
UnaryOperator
- extends Function
- require all type parameters to be the same type
- transforms parameter value into one of the same type
BinaryOperator
- extends BiFunction
- require all type parameters to be the same type
- merges two values into one of the same type
BooleanSupplier
- it is the only functional interface for boolean
Functional Interfaces for double, int, and long
- generics are gone from some of the interfaces, and instead the type name tells us what primitive type is involved
- In other cases, only the return type generic is needed because we’re converting a primitive int into an object.
- The single abstract method is often renamed when a primitive type is returned.

============

COLLECTIONS
- A collection is a group of objects contained in a single object.
- The Java Collections Framework is a set of classes in java.util for storing collections
- diamond operator (<>) is a shorthand notation that allows you to omit the generic type from the right side of a statement

public boolean add(E element)
- method inserts a new element into the Collection and returns whether it was successful.
- the boolean return value tells us whether element was added

public boolean remove(Object object)
- method removes a single matching value in the Collection and returns whether it was successful.
- the boolean return value tells us whether a match was removed

public void clear()
- method provides an easy way to discard all elements of the Collection

public boolean contains(Object object)
- method checks whether a certain value is in the Collection
- The contains() method calls equals() on elements of the ArrayList to see whether there are any matches.

public boolean removeIf(Predicate<? super E> filter)
- method removes all elements that match a condition
- we can specify what should be deleted using a block of code or even a method reference

public void forEach(Consumer<? super T> action)
- method that you can call on a Collection instead of writing a loop
- uses Consumer that takes a single parameter and doesn’t return anything.

boolean equals(Object object)
- you can compare two Collections to compare the type and contents
- ArrayList checks order, while HashSet does not

============

LIST INTERFACE [TABLE 9.1]

- ordered collection of elements that allows duplicate entries
- elements in a list can be accessed by an int index

■ ArrayList
- An ArrayList is like a resizable array. When elements are added, the ArrayList automatically grows.
  When you aren’t sure which collection to use, use an ArrayList
- can look up any element in constant time.
  Adding or removing an element is slower than accessing an element.
  It is good choice when you are reading more often than (or the same amount as) writing to the ArrayList
- three constructors that you need to know for the exam:
  new ArrayList<String>() --> create an empty ArrayList containing all the defaults
  new ArrayList<String>(list1) --> tells Java that we want to make a copy of another LinkedList
  new ArrayList<String>(10) --> create an ArrayList containing a specific number of slots, but again not to assign any

Believe it or not, this does compile. The type of the var is ArrayList<Object>.
Since there isn’t a type in the diamond operator, Java has to assume the most generic option it can.
Adding a String to the list is fine. You can add any subclass of Object.
However, in the loop, we need to use the Object type rather than String.
var list = new ArrayList<>();
list.add("a");
for (String s: list) { } // DOES NOT COMPILE

■ LinkedList
- implements both List and Deque
- has additional methods to facilitate adding or removing from the beginning and/or end of the list
- you can access, add to, and remove from the beginning and end of the list in constant time
- trade-off is that dealing with an arbitrary index takes linear time
- good choice when you’ll be using it as Deque
- two constructors that you need to know for the exam:
  new LinkedList<String>() --> create an empty LinkedList containing all the defaults
  new LinkedList<String>(linked1) --> tells Java that we want to make a copy of another LinkedList

Methods remove() gets tricky when you have an Integer type
- when you passing primitives int x then you are requesting deletion of the element at index x
- when you passing object Integer x, then you are deleting the value x

Converting from List to an Array
- The advantage of specifying a size of 0 for the parameter is that
  Java will create a new array of the proper size for the return value
- If you like, you can suggest a larger array to be used instead
- If the List fits in that array, it will be returned. Otherwise, a new array will be created
- Also, notice that line 18 clears the original List. This does not affect either array.
  The array is a newly created object with no relationship to the original List. It is simply a copy
13: List<String> list = new ArrayList<>();
14: list.add("hawk");
15: list.add("robin");
16: Object[] objectArray = list.toArray();
17: String[] stringArray = list.toArray(new String[0]);
18: list.clear();
19: System.out.println(objectArray.length); // 2
20: System.out.println(stringArray.length); // 2

============

SET INTERFACE

- collection that does not allow duplicate entries
- you can create an immutable Set in one line or make a copy of an existing one:
  --> Set.of('z', 'o', 'o')
  --> Set.copyOf(letters)

■ HashSet
- stores its elements in a hash table which means the keys are a hash and the values are an Object
- uses the hashCode() method of the objects to retrieve them more efficiently
- adding elements and checking whether an element is in the set both have constant time
- trade-off is that you lose the order in which you inserted the elements

■ TreeSet
- stores its elements in a sorted tree structure
- the set is always in sorted order
- trade-off is that adding and checking whether an element exists takes longer than with a HashSet,
  especially as the tree grows larger

============

QUEUE and DEQUE INTERFACES [TABLE 9.3, 9.4, 9.5]

- collection that orders its elements in a specific order for processing
- it is a FIFO (first-in, first-out) queue
- use a Queue when elements are added and removed in a specific order
- Deque (double-ended queue), often pronounced “deck,” is different from a regular
  queue in that you can insert and remove elements from both the front (head) and back (tail)
- In addition to FIFO queues, there are LIFO (last-in, first-out) queues, which are commonly referred to as stacks
  You always add to or remove from the top of the stack to avoid a mess.
  Luckily, we can use the same double-ended queue implementations
- it is really important to determine if it is being used as a FIFO queue, a LIFO stack, or a double-ended queue.
- To review, a FIFO queue is like a line of people. You get on in the back and off in the front.
  LIFO stack is like a stack of plates. You  put the plate on the top and take it off the top.
  A double-ended queue uses both ends.

■ ArrayDeque
- Double-ended queue

■ LinkedList
- in addition to being a list, it is a Deque
- it implements both the List and Deque interfaces
- trade-off is that it isn’t as efficient as a “pure” queue

============

MAP INTERFACE [Table 9.6]

- collection that maps keys to values, with no duplicate keys allowed
- elements in a map are key/value pairs
- Map doesn’t implement the Collection interface

■ HashMap
- stores the keys in a hash table
- uses the hashCode() method of the keys to retrieve their values more efficiently
- adding elements and retrieving the element by key both have constant time
- trade-off is that you lose the order in which you inserted the elements

■ TreeMap
- stores the keys in a sorted tree structure
- the keys are always in sorted order
- trade-off is that adding and checking whether a key is present takes longer as the tree grows larger

Merging Data [TABLE 9.7] !!!
- The merge() method adds logic of what to choose
- The merge() method also has logic for what happens if null values or missing keys are involved
- The mapping function is used only when there are two actual values to decide between.

TABLE 9.8, TABLE 9.9

============

SORTING DATA [TABLE 9.10]
- for numbers, it is numerical order
- for String objects, order is defined according to the Unicode character mapping
- When working with a String: numbers sort before letters, and uppercase letters sort before lowercase letters
- There is not a sort method on Set or Map. Both of those types are unordered

■ Comparable
- The Comparable interface has only one method
- Any object can be Comparable
- method is declared on the object that is being compared, and it takes one parameter
- The number 0 is returned when the current object is equivalent to the argument to compareTo().
- A negative number (less than 0) is returned when the current object is smaller than the argument to compareTo().
- A positive number (greater than 0) is returned when the current object is larger than the argument to compareTo().
- Remember that (id - a.id) sorts in ascending order, and (a.id - id) sorts in descending order.
- The Collections.sort() method uses the compareTo() method to sort
- You should keep compareTo() and equals() Consistent:
 --> The compareTo() method returns 0 if two objects are equal, while your equals() method returns true if two objects are equal
 --> A natural ordering that uses compareTo() is said to be consistent with equals if, and only if, x.equals(y) is true whenever x.compareTo(y) equals 0.
 --> x.equals(y) must be false whenever x.compareTo(y) is not 0

public interface Comparable<T> {
 int compareTo(T o);
}

■ Comparator
- Comparable can be used without an import statement (java.lang), while Comparator cannot (java.util)
- A negative number is returned if the first argument is smaller, zero if they are equal, and a positive number otherwise
- The compare() method can be declared in any code, and it takes two parameters
- is a functional interface since there is only one abstract method to implement
- we can rewrite the Comparator using a lambda expression

Comparing Multiple Fields [TABLE 9.11, 9.12]
- we can use method references and build the Comparator

Binary Search
- binarySearch is a method in Java used to find the position of a specific element in a sorted array or list.
- It works based on the divide-and-conquer principle.
- The input array or list must be sorted in ascending order (natural order) or by a specified comparator.
- If the array/list is unsorted, the result is undefined.
- Return Values:
  --> If the key is found: index of the key.
  --> If the key is not found: (-insertion_point-1), insertion_points is index where the key would be inserted to maintain the order.
  --> If duplicates exist, there is no guarantee which occurrence will be returned.
  --> Empty Array or List: −1

Collections.binarySearch(list, key);
Collections.binarySearch(list, key, comparator);

============

GENERICS
- The syntax for introducing a generic is to declare a formal type parameter in angle brackets
- Specifying a generic type allows the compiler to enforce proper use of the generic type
- This process of removing the generics syntax from your code is referred to as type erasure.
  Type erasure allows your code to be compatible with older versions of Java that do not contain generics
- To create a class with a generic parameter, you need to add <T> after the class name

■ 1 example
Only one of these two methods is allowed in a class because type erasure will reduce both sets of arguments to (List input):
public class LongTailAnimal {
 protected void chew(List<Object> input) {}
 protected void chew(List<Double> input) {} // DOES NOT COMPILE
}

■ 2 example
For the same reason, you also can’t overload a generic method from a parent class.
public class LongTailAnimal {
 protected void chew(List<Object> input) {}
}
public class Anteater extends LongTailAnimal {
 protected void chew(List<Double> input) {} // DOES NOT COMPILE
}

Both of these examples fail to compile because of type erasure.
In the compiled form, the generic type is dropped, and it appears as an invalid overloaded method.

■ 3 example
public class Anteater extends LongTailAnimal {
 protected void chew(List<Object> input) {}
 protected void chew(ArrayList<Double> input) {}
}

The first chew() method compiles because it uses the same generic type in the overridden
method as the one defined in the parent class. The second chew() method compiles as well.

However, it is an overloaded method because one of the method arguments is a List and the other is an ArrayList.
When working with generic methods, it’s important to consider the underlying type.

What You Can’t Do with Generic Types?
■ Call a constructor: Writing new T() is not allowed because at runtime, it would be
new Object().
■ Create an array of that generic type: This one is the most annoying, but it makes sense
because you’d be creating an array of Object values.
■ Call instanceof: This is not allowed because at runtime List<Integer> and
List<String> look the same to Java, thanks to type erasure.
■ Use a primitive type as a generic type parameter: This isn’t a big deal because you can
use the wrapper class instead. If you want a type of int, just use Integer.
■ Create a static variable as a generic type parameter: This is not allowed because the
type is linked to the instance of the class.

GENERIC METHODS:

■ Example 1
The method parameter is the generic type T. Before the return type, we declare the formal type parameter of <T>.
In the ship() method, we show how you can use the generic parameter in the return type, Crate<T>, for the method.

public class Handler {
  public static <T> void prepare(T t) {
    System.out.println("Preparing " + t);
  }
 public static <T> Crate<T> ship(T t) {
   System.out.println("Shipping " + t);
   return new Crate<T>();
 }
}

■ Example 2
2: public class More {
3:   public static <T> void sink(T t) { }
4:   public static <T> T identity(T t) { return t; }
5:   public static T noGood(T t) { return t; } // DOES NOT COMPILE
6: }

Line 3 shows the formal parameter type immediately before the return type of void.
Line 4 shows the return type being the formal parameter type.  It looks weird, but it is correct.
Line 5 omits the formal parameter type and therefore does not compile.

Example 3
When you have a method declare a generic parameter type, it is independent of the class generics.
Take a look at this class that declares a generic T at both levels:

1: public class TrickyCrate<T> {
2:   public <T> T tricky(T t) {
3:     return t;
4:   }
5: }

10: public static String crateName() {
11:   TrickyCrate<Robot> crate = new TrickyCrate<>();
12:   return crate.tricky("bot");
13: }

Clearly, “T is for tricky.”
On line 1, T is Robot because that is what gets referenced when constructing a Crate.
On line 2, T is String because that is what is passed to the method.

BOUNDING GENERIC TYPES
- wildcard generic type is an unknown generic type represented with a question mark (?)

■ Unbounded wildcard
Syntax: ?
Example: List<?> a = new ArrayList<String>()
- unbounded wildcard represents any data type
- unbounded generics are immutable
- use ? when you want to specify that any type is okay with you

■ Wildcard with upper bound
Syntax: ? extends type
Example: List<? extends Exception> a = new ArrayList<RuntimeException>()
- it says that any class that extends Exception or Exception itself can be used as the formal parameter type
- upper-bounded generics are immutable)

■ Wildcard with lower bound:
Syntax: ? super type
Example: List<? super Exception> a = new ArrayList<Object>()

============

============

============

============

============

============

#### STRONA - 598

1008
